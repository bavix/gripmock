// Code generated by GripMock. DO NOT EDIT.
//
// This file is generated by GripMock, a tool for generating gRPC mock servers.
// GripMock is a mock server for gRPC services. It's using a .proto file to generate implementation of gRPC service for you.
// You can use GripMock for setting up end-to-end testing or as a dummy server in a software development phase.
// The server implementation is in GoLang but the client can be any programming language that support gRPC.
//
// See https://github.com/bavix/gripmock for more information.
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net"
	"net/http"
	"os/signal"
	"slices"
	"strings"
	"syscall"
	"time"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	_ "google.golang.org/grpc/encoding/gzip"
	"google.golang.org/grpc/health"
	healthgrpc "google.golang.org/grpc/health/grpc_health_v1"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/reflection"
	"google.golang.org/grpc/status"
	jsonpb "google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/reflect/protoreflect"

	sdk "github.com/bavix/gripmock-sdk-go"
	"github.com/bavix/gripmock/pkg/deps"
	"github.com/bavix/gripmock/pkg/grpccontext"

	strictmode "github.com/bavix/gripmock/protogen/example/strictmode"
)

type GripMock struct {
	strictmode.UnsafeGripMockServer
	__builder__ *deps.Builder
}

func (s *GripMock) SayTitleHello(ctx context.Context, in *strictmode.SayTitleHelloRequest) (*strictmode.SayTitleHelloReply, error) {
	out := &strictmode.SayTitleHelloReply{}
	// Retrieve metadata from the incoming context.
	// The metadata is used to find the stub for the method being called.
	md, _ := metadata.FromIncomingContext(ctx)

	// Find the stub for the given service name, method name, and metadata.
	// The stub defines the input and output messages for the method.
	// If the stub is found, its output message is returned.
	// If the stub is not found, an error is returned.
	err := findStub(ctx, s.__builder__.Config().HTTPAddr, "GripMock", "SayTitleHello", md, in, out)

	// Return the output message and any error encountered while finding the stub.
	return out, err
}

func (s *GripMock) SayLowerHello(ctx context.Context, in *strictmode.SayLowerHelloRequest) (*strictmode.SayLowerHelloReply, error) {
	out := &strictmode.SayLowerHelloReply{}
	// Retrieve metadata from the incoming context.
	// The metadata is used to find the stub for the method being called.
	md, _ := metadata.FromIncomingContext(ctx)

	// Find the stub for the given service name, method name, and metadata.
	// The stub defines the input and output messages for the method.
	// If the stub is found, its output message is returned.
	// If the stub is not found, an error is returned.
	err := findStub(ctx, s.__builder__.Config().HTTPAddr, "GripMock", "sayLowerHello", md, in, out)

	// Return the output message and any error encountered while finding the stub.
	return out, err
}

func main() {
	ctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGTERM, syscall.SIGINT)
	defer cancel()

	builder, err := deps.New(ctx)
	if err != nil {
		log.Fatal(err)
	}

	lis, err := net.Listen(builder.Config().GRPCNetwork, builder.Config().GRPCAddr)
	if err != nil {
		builder.Logger().Fatal().Err(err).Msg("failed to listen")
	}

	s := grpc.NewServer(
		grpc.UnaryInterceptor(grpccontext.UnaryInterceptor(builder.Logger())),
		grpc.StreamInterceptor(grpccontext.StreamInterceptor(builder.Logger())),
	)

	healthcheck := health.NewServer()
	healthcheck.SetServingStatus("gripmock", healthgrpc.HealthCheckResponse_NOT_SERVING)

	strictmode.RegisterGripMockServer(s, &GripMock{__builder__: builder})

	healthgrpc.RegisterHealthServer(s, healthcheck)
	reflection.Register(s)

	builder.Logger().Info().
		Str("addr", builder.Config().GRPCAddr).
		Str("network", builder.Config().GRPCNetwork).
		Msg("Serving gRPC")

	// Health check goroutine to wait for the HTTP server to become ready.
	// Once the HTTP server is ready, it sets the gRPC server to SERVING state.
	go func() {
		// Create a new client to interact with the HTTP server API.
		api, err := sdk.NewClientWithResponses(
			fmt.Sprintf("http://%s/api", builder.Config().HTTPAddr),
			sdk.WithHTTPClient(http.DefaultClient),
		)
		if err != nil {
			return
		}

		// Create a context with a timeout of 120 seconds.
		ctx, cancel := context.WithTimeout(ctx, 120*time.Second)
		defer cancel()

		// Create a ticker to periodically check the readiness of the HTTP server.
		tick := time.NewTicker(250 * time.Millisecond)
		defer tick.Stop()

		for {
			select {
			// Check if the context is done.
			case <-ctx.Done():
				return

			// Check if the ticker has fired.
			case <-tick.C:
				// Call the Readiness API on the HTTP server.
				resp, err := api.ReadinessWithResponse(ctx)

				// If the API call is successful and the response is not nil,
				// set the gRPC server to SERVING state and log a message.
				if err == nil && resp.JSON200 != nil {
					healthcheck.SetServingStatus("gripmock", healthgrpc.HealthCheckResponse_SERVING)

					builder.Logger().Info().Msg("gRPC server is ready to accept requests")

					return
				}
			}
		}
	}()

	if err := s.Serve(lis); err != nil {
		builder.Logger().Fatal().Err(err).Msg("failed to serve")
	}
}

func findStub(ctx context.Context, addr string, service, method string, md metadata.MD, in, out protoreflect.ProtoMessage) error {
	// Create a new client with the configured HTTP address.
	// Add the default HTTP client as the transport.
	api, err := sdk.NewClientWithResponses(fmt.Sprintf("http://%s/api", addr),
		sdk.WithHTTPClient(http.DefaultClient),
	)
	if err != nil {
		return err
	}

	// Exclude headers that are not relevant for matching stubs.
	excludes := []string{":authority", "content-type", "grpc-accept-encoding", "user-agent"}

	// Create a map of headers to match with the input metadata.
	headers := make(map[string]string, len(md))
	for h, v := range md {
		// Exclude headers that are not relevant for matching stubs.
		if slices.Contains(excludes, h) {
			continue
		}

		// Join the values of the header with a semicolon.
		headers[h] = strings.Join(v, ";")
	}

	// Search for a stub that matches the given service, method, and headers.
	searchStub, err := api.SearchStubsWithResponse(ctx, sdk.SearchStubsJSONRequestBody{
		Service: service, // The name of the service.
		Method:  method,  // The name of the method.
		Headers: headers, // The headers to match.
		Data:    in,      // The input message.
	})
	if err != nil {
		return err
	}

	// If the search was unsuccessful, return an error with the response body.
	if searchStub.JSON200 == nil {
		return fmt.Errorf(string(searchStub.Body))
	}

	// If the search returned an error, return an error with the error code and message.
	if searchStub.JSON200.Error != "" || searchStub.JSON200.Code != nil {
		if searchStub.JSON200.Code == nil {
			return status.Error(codes.Aborted, searchStub.JSON200.Error)
		}

		if *searchStub.JSON200.Code != codes.OK {
			return status.Error(*searchStub.JSON200.Code, searchStub.JSON200.Error)
		}
	}

	// Convert the search result to JSON.
	data, err := json.Marshal(searchStub.JSON200.Data)
	if err != nil {
		return err
	}

	// Create a map of headers to set in the context.
	mdResp := make(metadata.MD, len(searchStub.JSON200.Headers))
	for k, v := range searchStub.JSON200.Headers {
		// Split the values of the header by semicolon and trim each value.
		splits := strings.Split(v, ";")
		for i, s := range splits {
			splits[i] = strings.TrimSpace(s)
		}

		mdResp[k] = splits
	}

	// Set the headers in the context.
	grpc.SetHeader(ctx, mdResp)

	// Unmarshal the search result into the output message.
	return jsonpb.Unmarshal(data, out)
}
