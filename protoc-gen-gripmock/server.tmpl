// Code generated by GripMock. DO NOT EDIT.
package main

import (
	"context"
	"errors"
	"slices"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"

	"github.com/gripmock/environment"
	"github.com/bytedance/sonic"
	jsonpb "google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/reflection"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/grpc/health"
	healthgrpc "google.golang.org/grpc/health/grpc_health_v1"
	_ "google.golang.org/grpc/encoding/gzip"
	"go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
	"go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"

	"github.com/bavix/gripmock/pkg/grpccontext"
	sdk "github.com/bavix/gripmock-sdk-go"
	"github.com/bavix/gripmock/pkg/dependencies"
)
{{ range $package, $alias := .Dependencies }}
import {{$alias}} "{{$package}}"
{{end}}

{{ range .Services }}
{{ template "services" . }}
{{ end }}

func main() {
	http.DefaultTransport = otelhttp.NewTransport(http.DefaultTransport)

	ctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGTERM, syscall.SIGINT)
	defer cancel()

	builder, err := dependencies.New(ctx, "gripmock-grpc")
	if err != nil {
		log.Fatal(err)
	}

	lis, err := net.Listen(builder.Config().GRPCNetwork, builder.Config().GRPCAddr)
	if err != nil {
		builder.Logger().Fatal().Err(err).Msg("failed to listen")
	}

	s := grpc.NewServer(
        grpc.StatsHandler(otelgrpc.NewServerHandler()),
        grpc.ChainUnaryInterceptor([]grpc.UnaryServerInterceptor{
            grpccontext.UnaryInterceptor(builder.Logger()),
        }...),
        grpc.ChainStreamInterceptor([]grpc.StreamServerInterceptor{
            grpccontext.StreamInterceptor(builder.Logger()),
        }...),
    )
	{{ range .Services }}
	{{ template "register_services" . }}
	{{ end }}

	healthgrpc.RegisterHealthServer(s, health.NewServer())
    reflection.Register(s)

	builder.Logger().Info().
	    Str("addr", fmt.Sprintf("%s://%s", builder.Config().GRPCNetwork, builder.Config().GRPCAddr)).
	    Msg("Serving gRPC")

	if err := s.Serve(lis); err != nil {
		builder.Logger().Fatal().Err(err).Msg("server ended")
	}
}

{{ template "find_stub" }}

{{ define "services" }}
type {{.Name}} struct{
    {{.Package}}Unsafe{{.Name}}Server
	__builder__ *dependencies.Builder
}

{{ template "methods" .}}
{{ end }}

{{ define "methods" }}
{{ range .Methods}}
	{{ if eq .MethodType "standard"}}
		{{ template "standard_method" .}}
	{{ else if eq .MethodType "server-stream"}}
		{{ template "server_stream_method" .}}
	{{ else if eq .MethodType "client-stream"}}
		{{ template "client_stream_method" .}}
	{{ else if eq .MethodType "bidirectional"}}
		{{ template "bidirectional_method" .}}
	{{ end }}
{{end}}
{{end}}

{{ define "standard_method" }}
func (s *{{.ServiceName}}) {{.Name}}(ctx context.Context, in *{{.Input}}) (*{{.Output}},error){
	out := &{{.Output}}{}
	md, _ := metadata.FromIncomingContext(ctx)
	err := findStub(ctx, s.__builder__.Config(), "{{.ServiceName}}", "{{.Name}}", md, in, out)
	return out, err
}
{{ end }}

{{ define "server_stream_method" }}
func (s *{{.ServiceName}}) {{.Name}}(in *{{.Input}},srv {{.SvcPackage}}{{.ServiceName}}_{{.Name}}Server) error {
	out := &{{.Output}}{}
	ctx := srv.Context()
	md, _ := metadata.FromIncomingContext(ctx)
	err := findStub(ctx, s.__builder__.Config(), "{{.ServiceName}}", "{{.Name}}", md, in, out)
	if err != nil {
		return err
	}

	return srv.Send(out)
}
{{ end }}

{{ define "client_stream_method"}}
func (s *{{.ServiceName}}) {{.Name}}(srv {{.SvcPackage}}{{.ServiceName}}_{{.Name}}Server) error {
	out := &{{.Output}}{}
	ctx := srv.Context()
	md, _ := metadata.FromIncomingContext(ctx)
	for {
		input,err := srv.Recv()
		if errors.Is(err, io.EOF) {
			return srv.SendAndClose(out)
		}
		err = findStub(ctx, s.__builder__.Config(), "{{.ServiceName}}","{{.Name}}",md,input,out)
		if err != nil {
			return err
		}
	}
}
{{ end }}

{{ define "bidirectional_method"}}
func (s *{{.ServiceName}}) {{.Name}}(srv {{.SvcPackage}}{{.ServiceName}}_{{.Name}}Server) error {
	ctx := srv.Context()
	md, _ := metadata.FromIncomingContext(ctx)
	for {
		in, err := srv.Recv()
		if errors.Is(err, io.EOF) {
			return nil
		}
		if err != nil {
			return err
		}

		out := &{{.Output}}{}
		err = findStub(ctx, s.__builder__.Config(), "{{.ServiceName}}","{{.Name}}", md, in, out)
		if err != nil {
			return err
		}

		if err := srv.Send(out); err != nil{
			return err
		}
	}
}
{{end}}


{{ define "register_services" }}
	{{.Package}}Register{{.Name}}Server(s, &{{.Name}}{__builder__: builder})
{{ end }}

{{ define "find_stub" }}
func findStub(ctx context.Context, conf environment.Config, service, method string, md metadata.MD, in, out protoreflect.ProtoMessage) error {
    api, err := sdk.NewClientWithResponses(fmt.Sprintf("http://%s/api", conf.HTTPAddr),
        sdk.WithHTTPClient(http.DefaultClient),
    )
    if err != nil {
        return err
    }

	excludes := []string{":authority", "content-type", "grpc-accept-encoding", "user-agent"}
	headers := make(map[string]string, len(md))
	for h, v := range md {
		if slices.Contains(excludes, h) {
			continue
		}

		headers[h] = strings.Join(v, ";")
	}

	searchStub, err := api.SearchStubsWithResponse(ctx, sdk.SearchStubsJSONRequestBody{
        Service: service,
        Method:  method,
        Headers: headers,
        Data: in,
    })
    if err != nil {
        return err
    }

    if searchStub.JSON200 == nil {
        return fmt.Errorf(string(searchStub.Body))
    }

    if searchStub.JSON200.Error != "" || searchStub.JSON200.Code != nil {
		if searchStub.JSON200.Code == nil {
		    return status.Error(codes.Aborted, searchStub.JSON200.Error)
		}

		if *searchStub.JSON200.Code != codes.OK {
			return status.Error(*searchStub.JSON200.Code, searchStub.JSON200.Error)
		}
	}

	data, err := sonic.Marshal(searchStub.JSON200.Data)
	if err != nil {
	    return err
	}

	mdResp := make(metadata.MD, len(searchStub.JSON200.Headers))
	for k, v := range searchStub.JSON200.Headers {
		splits := strings.Split(v, ";")
		for i, s := range splits {
			splits[i] = strings.TrimSpace(s)
		}

		mdResp[k] = splits
	}

	grpc.SetHeader(ctx, mdResp)

	return jsonpb.Unmarshal(data, out)
}
{{ end }}
