// Code generated by GripMock. DO NOT EDIT.
package main

import (
	"bytes"
	"errors"
	"slices"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net"
	"net/http"

	jsonpb "google.golang.org/protobuf/encoding/protojson"
	"golang.org/x/net/context"
	"github.com/goccy/go-json"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/reflection"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	_ "google.golang.org/grpc/encoding/gzip"
	"github.com/rs/zerolog"
	"github.com/bavix/gripmock/pkg/grpccontext"
	"go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
	"go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"

	"github.com/bavix/gripmock/pkg/sdk"
	"github.com/bavix/gripmock/pkg/utils"
	"github.com/bavix/gripmock/pkg/trace"
)
{{ range $package, $alias := .Dependencies }}
import {{$alias}} "{{$package}}"
{{end}}
const (
	GRPC_NETWORK  = "{{.GrpcNet}}"
	GRPC_ADDR  = "{{.GrpcAddr}}"
	HTTP_PORT = ":{{.AdminPort}}"
)

{{ range .Services }}
{{ template "services" . }}
{{ end }}

func main() {
	http.DefaultTransport = otelhttp.NewTransport(http.DefaultTransport)

	logger := utils.NewLogger(zerolog.InfoLevel)

	lis, err := net.Listen(GRPC_NETWORK, GRPC_ADDR)
	if err != nil {
	    logger.Fatal().Err(err).Msg("failed to listen")
	}

	ctx := logger.WithContext(context.Background())

    if err := trace.InitTracer(ctx, "gripmock-gen", trace.OTLPTrace{
        Host: "{{ .OtlpHost }}",
        Port: "{{ .OtlpPort }}",
        TLS: {{ .OtlpTLS }},
        SampleRatio: {{ .OtlpSampleRatio }},
    }); err != nil {
        logger.Err(err).Msg("connect to tracer")
    }

	s := grpc.NewServer(
        grpc.StatsHandler(otelgrpc.NewServerHandler()),
        grpc.ChainUnaryInterceptor([]grpc.UnaryServerInterceptor{
            grpccontext.UnaryInterceptor(ctx),
        }...),
        grpc.ChainStreamInterceptor([]grpc.StreamServerInterceptor{
            grpccontext.StreamInterceptor(ctx),
        }...),
    )
	{{ range .Services }}
	{{ template "register_services" . }}
	{{ end }}

    reflection.Register(s)

	logger.Info().
	    Str("addr", fmt.Sprintf("%s://%s", GRPC_NETWORK, GRPC_ADDR)).
	    Msg("Serving gRPC")

	if err := s.Serve(lis); err != nil {
	    logger.Fatal().Err(err).Msg("server ended")
	}
}

{{ template "find_stub" }}

{{ define "services" }}
type {{.Name}} struct{
    {{.Package}}Unsafe{{.Name}}Server
}

{{ template "methods" .}}
{{ end }}

{{ define "methods" }}
{{ range .Methods}}
	{{ if eq .MethodType "standard"}}
		{{ template "standard_method" .}}
	{{ else if eq .MethodType "server-stream"}}
		{{ template "server_stream_method" .}}
	{{ else if eq .MethodType "client-stream"}}
		{{ template "client_stream_method" .}}
	{{ else if eq .MethodType "bidirectional"}}
		{{ template "bidirectional_method" .}}
	{{ end }}
{{end}}
{{end}}

{{ define "standard_method" }}
func (s *{{.ServiceName}}) {{.Name}}(ctx context.Context, in *{{.Input}}) (*{{.Output}},error){
	out := &{{.Output}}{}
	md, _ := metadata.FromIncomingContext(ctx)
	err := findStub(ctx, "{{.ServiceName}}", "{{.Name}}", md, in, out)
	return out, err
}
{{ end }}

{{ define "server_stream_method" }}
func (s *{{.ServiceName}}) {{.Name}}(in *{{.Input}},srv {{.SvcPackage}}{{.ServiceName}}_{{.Name}}Server) error {
	out := &{{.Output}}{}
	ctx := srv.Context()
	md, _ := metadata.FromIncomingContext(ctx)
	err := findStub(ctx, "{{.ServiceName}}", "{{.Name}}", md, in, out)
	if err != nil {
		return err
	}

	return srv.Send(out)
}
{{ end }}

{{ define "client_stream_method"}}
func (s *{{.ServiceName}}) {{.Name}}(srv {{.SvcPackage}}{{.ServiceName}}_{{.Name}}Server) error {
	out := &{{.Output}}{}
	ctx := srv.Context()
	md, _ := metadata.FromIncomingContext(ctx)
	for {
		input,err := srv.Recv()
		if errors.Is(err, io.EOF) {
			return srv.SendAndClose(out)
		}
		err = findStub(ctx, "{{.ServiceName}}","{{.Name}}",md,input,out)
		if err != nil {
			return err
		}
	}
}
{{ end }}

{{ define "bidirectional_method"}}
func (s *{{.ServiceName}}) {{.Name}}(srv {{.SvcPackage}}{{.ServiceName}}_{{.Name}}Server) error {
	ctx := srv.Context()
	md, _ := metadata.FromIncomingContext(ctx)
	for {
		in, err := srv.Recv()
		if errors.Is(err, io.EOF) {
			return nil
		}
		if err != nil {
			return err
		}

		out := &{{.Output}}{}
		err = findStub(ctx, "{{.ServiceName}}","{{.Name}}", md, in, out)
		if err != nil {
			return err
		}

		if err := srv.Send(out); err != nil{
			return err
		}
	}
}
{{end}}


{{ define "register_services" }}
	{{.Package}}Register{{.Name}}Server(s, &{{.Name}}{})
{{ end }}

{{ define "find_stub" }}
type payload struct {
	Service string      `json:"service"`
	Method  string      `json:"method"`
	Data    interface{} `json:"data"`
}

type response struct {
	Data  interface{} `json:"data"`
	Error string      `json:"error"`
}

func findStub(ctx context.Context, service, method string, md metadata.MD, in, out protoreflect.ProtoMessage) error {
    api, err := sdk.NewClientWithResponses(fmt.Sprintf("http://localhost%s/api", HTTP_PORT),
        sdk.WithHTTPClient(http.DefaultClient),
    )
    if err != nil {
        return err
    }

	excludes := []string{":authority", "content-type", "grpc-accept-encoding", "user-agent"}
	headers := make(map[string]string, len(md))
	for h, v := range md {
		if slices.Contains(excludes, h) {
			continue
		}

		headers[h] = strings.Join(v, ";")
	}

	searchStub, err := api.SearchStubsWithResponse(ctx, sdk.SearchStubsJSONRequestBody{
        Service: service,
        Method:  method,
        Headers: headers,
        Data: in,
    })
    if err != nil {
        return err
    }

    if searchStub.JSON200 == nil {
        return fmt.Errorf(string(searchStub.Body))
    }

    if searchStub.JSON200.Error != "" || searchStub.JSON200.Code != nil {
		if searchStub.JSON200.Code == nil {
		    return status.Error(codes.Aborted, searchStub.JSON200.Error)
		}

		if *searchStub.JSON200.Code != codes.OK {
			return status.Error(*searchStub.JSON200.Code, searchStub.JSON200.Error)
		}
	}

	data, err := json.Marshal(searchStub.JSON200.Data)
	if err != nil {
	    return err
	}

	mdResp := make(metadata.MD, len(searchStub.JSON200.Headers))
	for k, v := range searchStub.JSON200.Headers {
		splits := strings.Split(v, ";")
		for i, s := range splits {
			splits[i] = strings.TrimSpace(s)
		}

		mdResp[k] = splits
	}

	grpc.SetHeader(ctx, mdResp)

	return jsonpb.Unmarshal(data, out)
}
{{ end }}
