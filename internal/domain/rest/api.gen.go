// Package rest provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package rest

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	gptypes "github.com/bavix/gripmock/v3/internal/infra/types"
	"github.com/gorilla/mux"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
	codes "google.golang.org/grpc/codes"
)

// Defines values for ListStubsV4ParamsOrder.
const (
	ListStubsV4ParamsOrderASC  ListStubsV4ParamsOrder = "ASC"
	ListStubsV4ParamsOrderDESC ListStubsV4ParamsOrder = "DESC"
)

// Defines values for SearchStubsV4ParamsOrder.
const (
	SearchStubsV4ParamsOrderASC  SearchStubsV4ParamsOrder = "ASC"
	SearchStubsV4ParamsOrderDESC SearchStubsV4ParamsOrder = "DESC"
)

// DataOutput Output for unary responses
type DataOutput struct {
	// Data Response data
	Data map[string]any `json:"data"`

	// Status gRPC status information
	Status *GrpcStatus `json:"status,omitempty"`
}

// GrpcStatus gRPC status information
type GrpcStatus struct {
	// Code gRPC status code
	Code *string `json:"code,omitempty"`

	// Message Status message
	Message *string `json:"message,omitempty"`
}

// ID defines model for ID.
type ID = openapi_types.UUID

// ListID defines model for ListID.
type ListID = []ID

// Matcher Unified matcher for v4 stubs
type Matcher struct {
	// Any OR logic - any of these matchers can match
	Any *[]Matcher `json:"any,omitempty"`

	// Contains Partial match criteria
	Contains *map[string]any `json:"contains,omitempty"`

	// Equals Exact match criteria
	Equals *map[string]any `json:"equals,omitempty"`

	// IgnoreArrayOrder Treat arrays as sets (ignore order)
	IgnoreArrayOrder *bool `json:"ignoreArrayOrder,omitempty"`

	// Matches Regex match criteria
	Matches *map[string]string `json:"matches,omitempty"`
}

// MessageOK defines model for MessageOK.
type MessageOK struct {
	Message string    `json:"message"`
	Time    time.Time `json:"time"`
}

// Method defines model for Method.
type Method struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// RequestHistory Request history item
type RequestHistory struct {
	// Duration Request duration in milliseconds
	Duration *float32 `json:"duration,omitempty"`

	// Id History item ID
	Id *string `json:"id,omitempty"`

	// Method Method name
	Method *string `json:"method,omitempty"`

	// Request Request data
	Request *map[string]any `json:"request,omitempty"`

	// Response Response data
	Response *map[string]any `json:"response,omitempty"`

	// Service Service name
	Service *string `json:"service,omitempty"`

	// Status Response status
	Status *string `json:"status,omitempty"`

	// Timestamp Request timestamp
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// SearchRequest defines model for SearchRequest.
type SearchRequest struct {
	Data    any       `json:"data"`
	Headers map[string]string `json:"headers,omitempty"`
	Id      *ID               `json:"id,omitempty"`
	Method  string            `json:"method"`
	Service string            `json:"service"`
}

// SearchResponse defines model for SearchResponse.
type SearchResponse struct {
	Code    codes.Code        `json:"code,omitempty"`
	Data    any       `json:"data"`
	Error   string            `json:"error"`
	Headers map[string]string `json:"headers,omitempty"`
}

// SendEach Template for sending multiple messages
type SendEach struct {
	// As Variable name for current item
	As *string `json:"as,omitempty"`

	// Delay Delay between messages
	Delay *string `json:"delay,omitempty"`

	// Items Template expression for items
	Items *string `json:"items,omitempty"`

	// Message Message template
	Message *map[string]any `json:"message,omitempty"`
}

// SequenceItem Item in a sequence rule
type SequenceItem struct {
	// Data Response data
	Data *map[string]any `json:"data,omitempty"`

	// Match Unified matcher for v4 stubs
	Match *Matcher `json:"match,omitempty"`

	// SendEach Template for sending multiple messages
	SendEach *SendEach `json:"sendEach,omitempty"`

	// Status gRPC status information
	Status *GrpcStatus `json:"status,omitempty"`

	// Stream Stream steps
	Stream *[]StreamStep `json:"stream,omitempty"`
}

// SequenceOutput Output for complex multi-step responses
type SequenceOutput struct {
	// Sequence Sequence items
	Sequence []SequenceItem `json:"sequence"`
}

// Service defines model for Service.
type Service struct {
	Id      string   `json:"id"`
	Methods []Method `json:"methods"`
	Name    string   `json:"name"`
	Package string   `json:"package"`
}

// StreamOutput Output for streaming responses
type StreamOutput struct {
	// Delay Delay before streaming
	Delay *string `json:"delay,omitempty"`

	// SendEach Template for sending multiple messages
	SendEach *SendEach `json:"sendEach,omitempty"`

	// Stream Stream steps
	Stream *[]StreamStep `json:"stream,omitempty"`
}

// StreamStep A step in streaming response
type StreamStep struct {
	// Delay Delay before next step
	Delay *string `json:"delay,omitempty"`

	// End gRPC status information
	End *GrpcStatus `json:"end,omitempty"`

	// Send Data to send
	Send *map[string]any `json:"send,omitempty"`
}

// Stub defines model for Stub.
type Stub struct {
	Headers StubHeaders `json:"headers,omitempty"`
	Id      *ID         `json:"id,omitempty"`
	Input   StubInput   `json:"input"`

	// Inputs Inputs to match against. If multiple inputs are provided, the stub will be matched if any of the inputs match.
	Inputs []StubInput `json:"inputs,omitempty"`
	Method string      `json:"method"`
	Output StubOutput  `json:"output"`

	// Priority Priority of the stub. Higher priority stubs are matched first.
	Priority int    `json:"priority,omitempty"`
	Service  string `json:"service"`
}

// StubAnalytics Analytics data for a stub
type StubAnalytics struct {
	// AverageResponseTime Average response time in milliseconds
	AverageResponseTime *float32 `json:"averageResponseTime,omitempty"`

	// Id Stub ID
	Id *string `json:"id,omitempty"`

	// LastUsed Last usage timestamp
	LastUsed *time.Time `json:"lastUsed,omitempty"`

	// Method Method name
	Method *string `json:"method,omitempty"`

	// Service Service name
	Service *string `json:"service,omitempty"`

	// Used Number of times used
	Used *int `json:"used,omitempty"`
}

// StubHeaders defines model for StubHeaders.
type StubHeaders struct {
	Contains map[string]string `json:"contains,omitempty"`
	Equals   map[string]string `json:"equals,omitempty"`
	Matches  map[string]string `json:"matches,omitempty"`
}

// StubInput defines model for StubInput.
type StubInput struct {
	Contains         map[string]any `json:"contains,omitempty"`
	Equals           map[string]any `json:"equals,omitempty"`
	IgnoreArrayOrder bool                   `json:"ignoreArrayOrder,omitempty"`
	Matches          map[string]any `json:"matches,omitempty"`
}

// StubList defines model for StubList.
type StubList = []Stub

// StubOutput defines model for StubOutput.
type StubOutput struct {
	Code codes.Code             `json:"code,omitempty"`
	Data map[string]any `json:"data,omitempty"`

	// Delay Delay before sending the response
	Delay   gptypes.Duration         `json:"delay,omitempty,omitzero"`
	Error   string                   `json:"error,omitempty"`
	Headers map[string]string        `json:"headers,omitempty"`
	Stream  []map[string]any `json:"stream,omitempty"`
}

// StubV4 V4 stub format with unified inputs and multiple outputs
type StubV4 struct {
	// Headers Unified matcher for v4 stubs
	Headers *Matcher `json:"headers,omitempty"`

	// Id Unique identifier
	Id *string `json:"id,omitempty"`

	// Inputs Input matching criteria (unified for unary/streaming)
	Inputs *[]Matcher `json:"inputs,omitempty"`

	// Method gRPC method name
	Method string `json:"method"`

	// Outputs Multiple possible outputs. Each output can be one of three types - data for unary responses, stream for server/bidirectional streaming, sequence for complex multi-step responses
	Outputs []StubV4_Outputs_Item `json:"outputs"`

	// Priority Priority for matching (higher = first)
	Priority *int `json:"priority,omitempty"`

	// ResponseHeaders Response headers to send
	ResponseHeaders *map[string]string `json:"responseHeaders,omitempty"`

	// ResponseTrailers Response trailers to send
	ResponseTrailers *map[string]string `json:"responseTrailers,omitempty"`

	// Service gRPC service name
	Service string `json:"service"`

	// Times Maximum number of times this stub can be used (0 = unlimited)
	Times *int `json:"times,omitempty"`
}

// StubV4_Outputs_Item defines model for StubV4.outputs.Item.
type StubV4_Outputs_Item struct {
	union json.RawMessage
}

// AddStubJSONBody defines parameters for AddStub.
type AddStubJSONBody struct {
	union json.RawMessage
}

// ListStubAnalyticsV4Params defines parameters for ListStubAnalyticsV4.
type ListStubAnalyticsV4Params struct {
	// UnderscoreStart Start index for pagination
	UnderscoreStart *int `form:"_start,omitempty" json:"_start,omitempty"`

	// UnderscoreEnd End index for pagination
	UnderscoreEnd *int `form:"_end,omitempty" json:"_end,omitempty"`
}

// ListHistoryV4Params defines parameters for ListHistoryV4.
type ListHistoryV4Params struct {
	// UnderscoreStart Start index for pagination
	UnderscoreStart *int `form:"_start,omitempty" json:"_start,omitempty"`

	// UnderscoreEnd End index for pagination
	UnderscoreEnd *int `form:"_end,omitempty" json:"_end,omitempty"`
}

// ListStubsV4Params defines parameters for ListStubsV4.
type ListStubsV4Params struct {
	// UnderscoreStart Start index for pagination
	UnderscoreStart *int `form:"_start,omitempty" json:"_start,omitempty"`

	// UnderscoreEnd End index for pagination
	UnderscoreEnd *int `form:"_end,omitempty" json:"_end,omitempty"`

	// UnderscoreSort Field to sort by
	UnderscoreSort *string `form:"_sort,omitempty" json:"_sort,omitempty"`

	// UnderscoreOrder Sort order (ASC or DESC)
	UnderscoreOrder *ListStubsV4ParamsOrder `form:"_order,omitempty" json:"_order,omitempty"`

	// Service Filter by service name
	Service *string `form:"service,omitempty" json:"service,omitempty"`

	// Method Filter by method name
	Method *string `form:"method,omitempty" json:"method,omitempty"`

	// Used Filter by usage status
	Used *bool `form:"used,omitempty" json:"used,omitempty"`

	// Q Search query
	Q *string `form:"q,omitempty" json:"q,omitempty"`
}

// ListStubsV4ParamsOrder defines parameters for ListStubsV4.
type ListStubsV4ParamsOrder string

// CreateStubV4JSONBody defines parameters for CreateStubV4.
type CreateStubV4JSONBody struct {
	union json.RawMessage
}

// CreateStubV4JSONBody1 defines parameters for CreateStubV4.
type CreateStubV4JSONBody1 = []StubV4

// BatchDeleteStubsV4JSONBody defines parameters for BatchDeleteStubsV4.
type BatchDeleteStubsV4JSONBody = []string

// LintStubsV4JSONBody defines parameters for LintStubsV4.
type LintStubsV4JSONBody = []StubV4

// SearchStubsV4Params defines parameters for SearchStubsV4.
type SearchStubsV4Params struct {
	// Q Search query
	Q string `form:"q" json:"q"`

	// UnderscoreStart Start index for pagination
	UnderscoreStart *int `form:"_start,omitempty" json:"_start,omitempty"`

	// UnderscoreEnd End index for pagination
	UnderscoreEnd *int `form:"_end,omitempty" json:"_end,omitempty"`

	// UnderscoreSort Field to sort by
	UnderscoreSort *string `form:"_sort,omitempty" json:"_sort,omitempty"`

	// UnderscoreOrder Sort order (ASC or DESC)
	UnderscoreOrder *SearchStubsV4ParamsOrder `form:"_order,omitempty" json:"_order,omitempty"`
}

// SearchStubsV4ParamsOrder defines parameters for SearchStubsV4.
type SearchStubsV4ParamsOrder string

// AddStubJSONRequestBody defines body for AddStub for application/json ContentType.
type AddStubJSONRequestBody AddStubJSONBody

// BatchStubsDeleteJSONRequestBody defines body for BatchStubsDelete for application/json ContentType.
type BatchStubsDeleteJSONRequestBody = ListID

// SearchStubsJSONRequestBody defines body for SearchStubs for application/json ContentType.
type SearchStubsJSONRequestBody = SearchRequest

// CreateStubV4JSONRequestBody defines body for CreateStubV4 for application/json ContentType.
type CreateStubV4JSONRequestBody CreateStubV4JSONBody

// BatchDeleteStubsV4JSONRequestBody defines body for BatchDeleteStubsV4 for application/json ContentType.
type BatchDeleteStubsV4JSONRequestBody = BatchDeleteStubsV4JSONBody

// LintStubsV4JSONRequestBody defines body for LintStubsV4 for application/json ContentType.
type LintStubsV4JSONRequestBody = LintStubsV4JSONBody

// DryRunStubMatchV4JSONRequestBody defines body for DryRunStubMatchV4 for application/json ContentType.
type DryRunStubMatchV4JSONRequestBody = SearchRequest

// UpdateStubV4JSONRequestBody defines body for UpdateStubV4 for application/json ContentType.
type UpdateStubV4JSONRequestBody = StubV4

// AsDataOutput returns the union data inside the StubV4_Outputs_Item as a DataOutput
func (t StubV4_Outputs_Item) AsDataOutput() (DataOutput, error) {
	var body DataOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataOutput overwrites any union data inside the StubV4_Outputs_Item as the provided DataOutput
func (t *StubV4_Outputs_Item) FromDataOutput(v DataOutput) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDataOutput performs a merge with any union data inside the StubV4_Outputs_Item, using the provided DataOutput
func (t *StubV4_Outputs_Item) MergeDataOutput(v DataOutput) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStreamOutput returns the union data inside the StubV4_Outputs_Item as a StreamOutput
func (t StubV4_Outputs_Item) AsStreamOutput() (StreamOutput, error) {
	var body StreamOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStreamOutput overwrites any union data inside the StubV4_Outputs_Item as the provided StreamOutput
func (t *StubV4_Outputs_Item) FromStreamOutput(v StreamOutput) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStreamOutput performs a merge with any union data inside the StubV4_Outputs_Item, using the provided StreamOutput
func (t *StubV4_Outputs_Item) MergeStreamOutput(v StreamOutput) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSequenceOutput returns the union data inside the StubV4_Outputs_Item as a SequenceOutput
func (t StubV4_Outputs_Item) AsSequenceOutput() (SequenceOutput, error) {
	var body SequenceOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSequenceOutput overwrites any union data inside the StubV4_Outputs_Item as the provided SequenceOutput
func (t *StubV4_Outputs_Item) FromSequenceOutput(v SequenceOutput) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSequenceOutput performs a merge with any union data inside the StubV4_Outputs_Item, using the provided SequenceOutput
func (t *StubV4_Outputs_Item) MergeSequenceOutput(v SequenceOutput) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StubV4_Outputs_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StubV4_Outputs_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Liveness check
	// (GET /health/liveness)
	Liveness(w http.ResponseWriter, r *http.Request)
	// Readiness check
	// (GET /health/readiness)
	Readiness(w http.ResponseWriter, r *http.Request)
	// Services
	// (GET /services)
	ServicesList(w http.ResponseWriter, r *http.Request)
	// Service methods
	// (GET /services/{serviceID}/methods)
	ServiceMethodsList(w http.ResponseWriter, r *http.Request, serviceID string)
	// Remove all stubs
	// (DELETE /stubs)
	PurgeStubs(w http.ResponseWriter, r *http.Request)
	// Getting a list of stubs
	// (GET /stubs)
	ListStubs(w http.ResponseWriter, r *http.Request)
	// Add a new stub to the store
	// (POST /stubs)
	AddStub(w http.ResponseWriter, r *http.Request)
	// Deletes a batch of stubs by IDs
	// (POST /stubs/batchDelete)
	BatchStubsDelete(w http.ResponseWriter, r *http.Request)
	// Stub storage search
	// (POST /stubs/search)
	SearchStubs(w http.ResponseWriter, r *http.Request)
	// Getting a list of unused stubs
	// (GET /stubs/unused)
	ListUnusedStubs(w http.ResponseWriter, r *http.Request)
	// Getting a list of used stubs
	// (GET /stubs/used)
	ListUsedStubs(w http.ResponseWriter, r *http.Request)
	// Deletes stub by ID
	// (DELETE /stubs/{uuid})
	DeleteStubByID(w http.ResponseWriter, r *http.Request, uuid ID)
	// Get Stub by ID
	// (GET /stubs/{uuid})
	FindByID(w http.ResponseWriter, r *http.Request, uuid ID)
	// List stub analytics
	// (GET /v4/analytics/stubs)
	ListStubAnalyticsV4(w http.ResponseWriter, r *http.Request, params ListStubAnalyticsV4Params)
	// Clear request history
	// (DELETE /v4/history)
	ClearHistoryV4(w http.ResponseWriter, r *http.Request)
	// List request history
	// (GET /v4/history)
	ListHistoryV4(w http.ResponseWriter, r *http.Request, params ListHistoryV4Params)
	// Get request history item
	// (GET /v4/history/{id})
	GetHistoryItemV4(w http.ResponseWriter, r *http.Request, id string)
	// List stubs with filtering, sorting and pagination
	// (GET /v4/stubs)
	ListStubsV4(w http.ResponseWriter, r *http.Request, params ListStubsV4Params)
	// Create stub(s)
	// (POST /v4/stubs)
	CreateStubV4(w http.ResponseWriter, r *http.Request)
	// Delete multiple stubs
	// (POST /v4/stubs/batchDelete)
	BatchDeleteStubsV4(w http.ResponseWriter, r *http.Request)
	// Lint stubs
	// (POST /v4/stubs/lint)
	LintStubsV4(w http.ResponseWriter, r *http.Request)
	// Dry run stub matching
	// (POST /v4/stubs/match:dryRun)
	DryRunStubMatchV4(w http.ResponseWriter, r *http.Request)
	// Search stubs
	// (GET /v4/stubs/search)
	SearchStubsV4(w http.ResponseWriter, r *http.Request, params SearchStubsV4Params)
	// Delete stub
	// (DELETE /v4/stubs/{id})
	DeleteStubV4(w http.ResponseWriter, r *http.Request, id string)
	// Get stub by ID
	// (GET /v4/stubs/{id})
	GetStubV4(w http.ResponseWriter, r *http.Request, id string)
	// Update stub
	// (PUT /v4/stubs/{id})
	UpdateStubV4(w http.ResponseWriter, r *http.Request, id string)
	// Get stub analytics
	// (GET /v4/stubs/{id}/analytics)
	GetStubAnalyticsV4(w http.ResponseWriter, r *http.Request, id string)
	// Reset stub times
	// (POST /v4/stubs/{id}/resetTimes)
	ResetStubTimesV4(w http.ResponseWriter, r *http.Request, id string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// Liveness operation middleware
func (siw *ServerInterfaceWrapper) Liveness(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Liveness(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Readiness operation middleware
func (siw *ServerInterfaceWrapper) Readiness(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Readiness(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ServicesList operation middleware
func (siw *ServerInterfaceWrapper) ServicesList(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ServicesList(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ServiceMethodsList operation middleware
func (siw *ServerInterfaceWrapper) ServiceMethodsList(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "serviceID" -------------
	var serviceID string

	err = runtime.BindStyledParameterWithOptions("simple", "serviceID", mux.Vars(r)["serviceID"], &serviceID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "serviceID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ServiceMethodsList(w, r, serviceID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PurgeStubs operation middleware
func (siw *ServerInterfaceWrapper) PurgeStubs(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PurgeStubs(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListStubs operation middleware
func (siw *ServerInterfaceWrapper) ListStubs(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListStubs(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AddStub operation middleware
func (siw *ServerInterfaceWrapper) AddStub(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddStub(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// BatchStubsDelete operation middleware
func (siw *ServerInterfaceWrapper) BatchStubsDelete(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BatchStubsDelete(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SearchStubs operation middleware
func (siw *ServerInterfaceWrapper) SearchStubs(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SearchStubs(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListUnusedStubs operation middleware
func (siw *ServerInterfaceWrapper) ListUnusedStubs(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUnusedStubs(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListUsedStubs operation middleware
func (siw *ServerInterfaceWrapper) ListUsedStubs(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUsedStubs(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteStubByID operation middleware
func (siw *ServerInterfaceWrapper) DeleteStubByID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid ID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", mux.Vars(r)["uuid"], &uuid, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uuid", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteStubByID(w, r, uuid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// FindByID operation middleware
func (siw *ServerInterfaceWrapper) FindByID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid ID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", mux.Vars(r)["uuid"], &uuid, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uuid", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindByID(w, r, uuid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListStubAnalyticsV4 operation middleware
func (siw *ServerInterfaceWrapper) ListStubAnalyticsV4(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListStubAnalyticsV4Params

	// ------------- Optional query parameter "_start" -------------

	err = runtime.BindQueryParameter("form", true, false, "_start", r.URL.Query(), &params.UnderscoreStart)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "_start", Err: err})
		return
	}

	// ------------- Optional query parameter "_end" -------------

	err = runtime.BindQueryParameter("form", true, false, "_end", r.URL.Query(), &params.UnderscoreEnd)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "_end", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListStubAnalyticsV4(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ClearHistoryV4 operation middleware
func (siw *ServerInterfaceWrapper) ClearHistoryV4(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ClearHistoryV4(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListHistoryV4 operation middleware
func (siw *ServerInterfaceWrapper) ListHistoryV4(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListHistoryV4Params

	// ------------- Optional query parameter "_start" -------------

	err = runtime.BindQueryParameter("form", true, false, "_start", r.URL.Query(), &params.UnderscoreStart)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "_start", Err: err})
		return
	}

	// ------------- Optional query parameter "_end" -------------

	err = runtime.BindQueryParameter("form", true, false, "_end", r.URL.Query(), &params.UnderscoreEnd)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "_end", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListHistoryV4(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetHistoryItemV4 operation middleware
func (siw *ServerInterfaceWrapper) GetHistoryItemV4(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", mux.Vars(r)["id"], &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHistoryItemV4(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListStubsV4 operation middleware
func (siw *ServerInterfaceWrapper) ListStubsV4(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListStubsV4Params

	// ------------- Optional query parameter "_start" -------------

	err = runtime.BindQueryParameter("form", true, false, "_start", r.URL.Query(), &params.UnderscoreStart)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "_start", Err: err})
		return
	}

	// ------------- Optional query parameter "_end" -------------

	err = runtime.BindQueryParameter("form", true, false, "_end", r.URL.Query(), &params.UnderscoreEnd)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "_end", Err: err})
		return
	}

	// ------------- Optional query parameter "_sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "_sort", r.URL.Query(), &params.UnderscoreSort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "_sort", Err: err})
		return
	}

	// ------------- Optional query parameter "_order" -------------

	err = runtime.BindQueryParameter("form", true, false, "_order", r.URL.Query(), &params.UnderscoreOrder)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "_order", Err: err})
		return
	}

	// ------------- Optional query parameter "service" -------------

	err = runtime.BindQueryParameter("form", true, false, "service", r.URL.Query(), &params.Service)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "service", Err: err})
		return
	}

	// ------------- Optional query parameter "method" -------------

	err = runtime.BindQueryParameter("form", true, false, "method", r.URL.Query(), &params.Method)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "method", Err: err})
		return
	}

	// ------------- Optional query parameter "used" -------------

	err = runtime.BindQueryParameter("form", true, false, "used", r.URL.Query(), &params.Used)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "used", Err: err})
		return
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListStubsV4(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateStubV4 operation middleware
func (siw *ServerInterfaceWrapper) CreateStubV4(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateStubV4(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// BatchDeleteStubsV4 operation middleware
func (siw *ServerInterfaceWrapper) BatchDeleteStubsV4(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BatchDeleteStubsV4(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LintStubsV4 operation middleware
func (siw *ServerInterfaceWrapper) LintStubsV4(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LintStubsV4(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DryRunStubMatchV4 operation middleware
func (siw *ServerInterfaceWrapper) DryRunStubMatchV4(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DryRunStubMatchV4(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SearchStubsV4 operation middleware
func (siw *ServerInterfaceWrapper) SearchStubsV4(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchStubsV4Params

	// ------------- Required query parameter "q" -------------

	if paramValue := r.URL.Query().Get("q"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "q"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	// ------------- Optional query parameter "_start" -------------

	err = runtime.BindQueryParameter("form", true, false, "_start", r.URL.Query(), &params.UnderscoreStart)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "_start", Err: err})
		return
	}

	// ------------- Optional query parameter "_end" -------------

	err = runtime.BindQueryParameter("form", true, false, "_end", r.URL.Query(), &params.UnderscoreEnd)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "_end", Err: err})
		return
	}

	// ------------- Optional query parameter "_sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "_sort", r.URL.Query(), &params.UnderscoreSort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "_sort", Err: err})
		return
	}

	// ------------- Optional query parameter "_order" -------------

	err = runtime.BindQueryParameter("form", true, false, "_order", r.URL.Query(), &params.UnderscoreOrder)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "_order", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SearchStubsV4(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteStubV4 operation middleware
func (siw *ServerInterfaceWrapper) DeleteStubV4(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", mux.Vars(r)["id"], &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteStubV4(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetStubV4 operation middleware
func (siw *ServerInterfaceWrapper) GetStubV4(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", mux.Vars(r)["id"], &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStubV4(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateStubV4 operation middleware
func (siw *ServerInterfaceWrapper) UpdateStubV4(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", mux.Vars(r)["id"], &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateStubV4(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetStubAnalyticsV4 operation middleware
func (siw *ServerInterfaceWrapper) GetStubAnalyticsV4(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", mux.Vars(r)["id"], &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStubAnalyticsV4(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ResetStubTimesV4 operation middleware
func (siw *ServerInterfaceWrapper) ResetStubTimesV4(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", mux.Vars(r)["id"], &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResetStubTimesV4(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{})
}

type GorillaServerOptions struct {
	BaseURL          string
	BaseRouter       *mux.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r *mux.Router) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r *mux.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options GorillaServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = mux.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.HandleFunc(options.BaseURL+"/health/liveness", wrapper.Liveness).Methods("GET")

	r.HandleFunc(options.BaseURL+"/health/readiness", wrapper.Readiness).Methods("GET")

	r.HandleFunc(options.BaseURL+"/services", wrapper.ServicesList).Methods("GET")

	r.HandleFunc(options.BaseURL+"/services/{serviceID}/methods", wrapper.ServiceMethodsList).Methods("GET")

	r.HandleFunc(options.BaseURL+"/stubs", wrapper.PurgeStubs).Methods("DELETE")

	r.HandleFunc(options.BaseURL+"/stubs", wrapper.ListStubs).Methods("GET")

	r.HandleFunc(options.BaseURL+"/stubs", wrapper.AddStub).Methods("POST")

	r.HandleFunc(options.BaseURL+"/stubs/batchDelete", wrapper.BatchStubsDelete).Methods("POST")

	r.HandleFunc(options.BaseURL+"/stubs/search", wrapper.SearchStubs).Methods("POST")

	r.HandleFunc(options.BaseURL+"/stubs/unused", wrapper.ListUnusedStubs).Methods("GET")

	r.HandleFunc(options.BaseURL+"/stubs/used", wrapper.ListUsedStubs).Methods("GET")

	r.HandleFunc(options.BaseURL+"/stubs/{uuid}", wrapper.DeleteStubByID).Methods("DELETE")

	r.HandleFunc(options.BaseURL+"/stubs/{uuid}", wrapper.FindByID).Methods("GET")

	r.HandleFunc(options.BaseURL+"/v4/analytics/stubs", wrapper.ListStubAnalyticsV4).Methods("GET")

	r.HandleFunc(options.BaseURL+"/v4/history", wrapper.ClearHistoryV4).Methods("DELETE")

	r.HandleFunc(options.BaseURL+"/v4/history", wrapper.ListHistoryV4).Methods("GET")

	r.HandleFunc(options.BaseURL+"/v4/history/{id}", wrapper.GetHistoryItemV4).Methods("GET")

	r.HandleFunc(options.BaseURL+"/v4/stubs", wrapper.ListStubsV4).Methods("GET")

	r.HandleFunc(options.BaseURL+"/v4/stubs", wrapper.CreateStubV4).Methods("POST")

	r.HandleFunc(options.BaseURL+"/v4/stubs/batchDelete", wrapper.BatchDeleteStubsV4).Methods("POST")

	r.HandleFunc(options.BaseURL+"/v4/stubs/lint", wrapper.LintStubsV4).Methods("POST")

	r.HandleFunc(options.BaseURL+"/v4/stubs/match:dryRun", wrapper.DryRunStubMatchV4).Methods("POST")

	r.HandleFunc(options.BaseURL+"/v4/stubs/search", wrapper.SearchStubsV4).Methods("GET")

	r.HandleFunc(options.BaseURL+"/v4/stubs/{id}", wrapper.DeleteStubV4).Methods("DELETE")

	r.HandleFunc(options.BaseURL+"/v4/stubs/{id}", wrapper.GetStubV4).Methods("GET")

	r.HandleFunc(options.BaseURL+"/v4/stubs/{id}", wrapper.UpdateStubV4).Methods("PUT")

	r.HandleFunc(options.BaseURL+"/v4/stubs/{id}/analytics", wrapper.GetStubAnalyticsV4).Methods("GET")

	r.HandleFunc(options.BaseURL+"/v4/stubs/{id}/resetTimes", wrapper.ResetStubTimesV4).Methods("POST")

	return r
}
